# Day 1
https://docs.google.com/presentation/d/14onkgw7BWkwLky2_QUSElZA0fNEF7PXVpO_r6IpuutA/edit?usp=sharing
- Introduction

![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/797d2dc9-b701-4c8c-816f-edde8ef71ca1)

## 1. What is Problem?
> Its like puzzle needs to be solved

### How Mathematicians will be comfortable with programming?
> Cuz maths teaches the logical way to solve, hence it helps in problem solving

### Who were the first software developer?
> Mathematicians

## 2. Problem Analysis
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/3eb6f2d9-395c-4371-9fd4-36521ad26a22)
1. Define:
 - Clearly articulate the problem to be solved.
 - Understand the objectives and requirements from stakeholders.
2. Analyze:
 - Gather relevant data and information related to the problem.
 - Identify patterns, trends, and potential root causes.
3. Design:
 - Create a high-level plan or concept for solving the problem.
 - Start with broader strokes, outlining major components or steps.
 - Gradually refine the design, considering specific details and potential challenges.
4. Seeing Possible Outcomes:
 - Conduct scenario analysis or use other techniques to envision different outcomes.
 - Embrace an iterative approach to refine the design based on potential scenarios.
5. Decide the Solution:
 - Finalize the design by evaluating it against stakeholder needs and requirements.
 - Seek feedback from clients or relevant parties to validate the proposed solution.
6. Implementation:
 - Translate the finalized design into action, typically through coding or other means.
 - Follow best practices and methodologies during implementation.
7. Follow Up:
 - Test the implemented solution to ensure it meets quality standards and functions as intended.
 - Deploy the solution into the relevant environment.
 - Gather feedback from users or stakeholders and incorporate it for continuous improvement.

This structured approach ensures thorough problem understanding, thoughtful solution design, and effective implementation, leading to successful outcomes.

## 3. Programming Skills
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/4276cd49-19c6-4608-b47e-1d4c31ff262f)

### Performance Measure
-> mail your manager your highlights (what extra you've done) - cuz of this you've prepared points for yearly meeting like what  you've contributed. (not expected from you but help you)

![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/4e9f668e-ddd5-4906-bbf9-ddbd089667f8)
1. Timeliness: Timeliness measures how promptly tasks or projects are completed within the specified timeframe. For example, if a software developer consistently delivers their assigned tasks before the deadline, they demonstrate high timeliness.
2. Quality of Work: Quality of work assesses the standard and accuracy of the output produced. For instance, if a graphic designer consistently creates visually appealing and error-free designs that meet or exceed client expectations, they exhibit high quality of work.
3. Customer Orientation: Customer orientation evaluates how well an individual or team understands and meets the needs of their customers or clients. For example, a customer service representative who actively listens to customer concerns, provides helpful solutions, and ensures customer satisfaction demonstrates strong customer orientation.
4. Optimal Solution: Optimal solution measures the effectiveness and efficiency of the solutions provided to solve problems or address challenges. For instance, if a data analyst devises a data processing algorithm that significantly reduces processing time and resource utilization while maintaining accuracy, they achieve an optimal solution.
5. Team Satisfaction: Team satisfaction evaluates the morale, collaboration, and overall happiness of team members. For example, if a project manager fosters a positive work environment, encourages open communication, and ensures that team members feel valued and supported, they contribute to high team satisfaction.

These performance measures help organizations gauge the effectiveness, efficiency, and alignment of individuals or teams with organizational goals and objectives.

### Types of Problem
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/2db7763c-7b48-46b9-8508-52c65c4fbd2c)

1. *concurrent*
    - Concurrent problems involve multiple tasks or processes that can potentially run simultaneously or concurrently.
    - These tasks may share resources, such as memory or files, and may need to coordinate with each other to avoid conflicts and ensure correctness.
    - Examples of concurrent problems include multi-threading in software applications, concurrent access to shared data structures, and distributed computing tasks.
 
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/d139d2a6-74b2-4501-8dea-6483f64a31ec)

2. *sequential*
   - Sequential problems involve tasks or processes that must be executed in a specific order, one after the other, without any parallel execution.
   - These problems typically have a clear sequence of steps or dependencies that must be followed.
   - Examples of sequential problems include sorting algorithms like bubble sort or insertion sort, where each step depends on the result of the previous step.
 
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/d22a4ac2-61b0-4704-b077-c3ee79172c28)

3. *Distributed Problems:*
   - Distributed problems involve tasks or processes that are spread across multiple computers or nodes in a network.
   - These tasks often require communication and coordination between different nodes to achieve a common goal.
   - Examples of distributed problems include distributed databases, distributed file systems, and distributed computing tasks such as map-reduce.

 ![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/82afecc4-465b-4258-9223-2a6b3bea5d71)

4. *Event-Based Problems:*
   - Event-based problems involve responding to events or triggers that occur asynchronously.
   - These events can come from various sources, such as user input, hardware interrupts, or messages from other processes.
   - Event-based systems typically use event loops or callback mechanisms to handle events as they occur.
   - Examples of event-based problems include graphical user interfaces (GUIs), network servers handling incoming requests, and real-time systems reacting to sensor data.
  
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/0ed8590c-3ae9-4a3a-adba-ef9022498dca)

Each type of problem requires different approaches and techniques for solution development, and understanding the characteristics of each can help in choosing the most appropriateÂ strategy.

### How does App work
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/084d0c8f-7baf-4d6e-836f-e4bad399288c)

 - Concurrent: Simultaneous handling of multiple user requests, ensuring data integrity.
Example: Managing orders from multiple users placed simultaneously.
 - Sequential: Tasks executed in a specific order for order processing and transaction integrity.
Example: Verifying item availability, calculating total price, processing payment, and confirming orders.
 - Distributed: Operating across multiple interconnected servers to handle high traffic and ensure scalability.
Example: Servers distributed geographically to serve users in different regions.
 - Event-Based: Asynchronous response to events or triggers for real-time updates and notifications.
Example: Generating notifications to kitchen staff and updating order status in real-time when a new order is placed.

## 4. Problem Solving Methods
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/a5cabf37-65f4-42c4-bac9-98479e061cc3)

**1. Brute force:**   Brute force involves trying every possible solution to a problem until a satisfactory one is found. <br>
Example: To find the maximum value in an array, you iterate through each element and compare it with the current maximum value.

   ![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/17e75afd-62a3-4fb8-8bdf-40feaa716b58)
  ![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/60c94654-eec7-4629-8471-5362d1d6c602)

**2. Greedy:**
   Greedy algorithms make locally optimal choices at each step with the hope of finding a global optimum. <br>
   Example: The greedy algorithm for the "Coin Change" problem selects the largest coin denomination that is less than or equal to the remaining amount at each step.
   
   ![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/7ec4430c-cd99-4c61-b09b-cf252431d353)

**3. Divide and Conquer:**
Divide and conquer involves breaking a problem into smaller, more manageable subproblems, solving them recursively, and combining their solutions to solve the original problem. <br>
Example: Merge Sort divides an array into two halves, sorts each half recursively, and then merges the sorted halves.

![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/920508d0-f4d0-43f5-9bf9-a96b7d720c31)

**4. Dynamic Programming:**
Dynamic programming solves problems by breaking them down into simpler overlapping subproblems and solving each subproblem only once, storing the results to avoid redundant calculations.(pattern - no. of ways) <br>
Example: The Fibonacci sequence can be efficiently calculated using dynamic programming to avoid redundant calculations of Fibonacci numbers.

![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/88c8b8b4-6b31-4531-aa45-185d76b681e6)

Each of these problem-solving methods has its strengths and weaknesses, and choosing the appropriate method depends on the nature of the problem and its constraints.

## 5. Modeling Tools

**1. Flow Charts:**
Flow charts are graphical representations of processes or workflows. They use different shapes to represent various steps, decisions, and actions in a process, connected by arrows indicating the flow. <br>
Example: Flow chart for an online shopping process, showing steps like selecting items, adding to cart, checkout, and payment. <br>
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/7ab9c622-31c4-419d-bc41-e474d56c8de0)
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/d7255433-dee3-4321-bf04-502b42ed195c)
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/96bf2ae8-84f0-45d8-85cc-94ba8a678d80)


**2. Data Flow Diagrams (DFD):**
DFDs depict the flow of data through a system. They illustrate how data is input, processed, stored, and outputted within a system or process. DFDs consist of processes, data stores, data flows, and external entities. <br>
Example: DFD for a student registration system, showing processes like student registration, course selection, and generating student IDs. <br>
![WhatsApp Image 2024-04-22 at 15 51 39_501a883a](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/ce3cf592-646a-4eaa-ba49-1323baf64179)

**3. Entity-Relationship (ER) Diagram:**
ER diagrams represent the relationships between entities in a database. They use entities (objects), attributes, and relationships to model the structure of a database schema. ER diagrams are useful for designing and visualizing database schemas. <br>
Example: ER diagram for a university database, showing entities like students, courses, professors, and relationships like enrollment and teaching. <br>
![WhatsApp Image 2024-04-22 at 15 51 39_a7c626b3](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/220050b6-592f-47c6-8f64-c96154a6087f)


**4. Unified Modeling Language (UML):**
UML is a standardized modeling language used to visualize, specify, construct, and document software systems. It includes various diagrams like class diagrams, use case diagrams, sequence diagrams, and more, each serving different modeling purposes. <br>
Example: UML class diagram for a Python application, showing classes, attributes, methods, and their relationships. <br>
![WhatsApp Image 2024-04-22 at 15 51 40_7f98316b](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/1527ccae-e7c1-4284-af3d-cc3f36e84e61)


In Python, you can use libraries like pygraphviz, matplotlib, or graphviz to create visual representations of these models programmatically. You can also use specialized UML modeling tools that support Python code generation to create UML diagrams directly from your code.

## 6. Algorithm
![WhatsApp Image 2024-04-22 at 15 51 41_16e4dc42](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/ac406471-24c5-4ebe-b115-64c3ec289fbe)

![WhatsApp Image 2024-04-22 at 15 51 41_1a514c45](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/5ad710a7-5730-4d96-80be-8b5b0eb8bcdc)

![WhatsApp Image 2024-04-22 at 15 51 42_0bb67d5c](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/9be6ec50-8afa-4bf3-855c-48dda682f5e9)

### Different Patterns in Algo
![WhatsApp Image 2024-04-22 at 15 51 43_59ae8362](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/895be501-c4ea-4404-8731-96caba3c948e)

![WhatsApp Image 2024-04-22 at 15 51 43_d0dd2a09](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/86e681c6-c29c-41d3-9b78-989579717d08)

![WhatsApp Image 2024-04-22 at 15 51 44_5126b8a5](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/1c5c12e2-3182-4e8b-80da-e5544b63116c)

## 7. Data Structures
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/52c6e42f-7dd3-4b09-9783-247461d0b1a9)

### Types of DS
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/b416cde2-d046-4dfb-9ec2-e58054c95790)

**Linear Data Structures:** Linear data structures organize data elements sequentially, one after the other, in a linear order.
Elements are accessed and traversed sequentially, typically from the beginning to the end.
Examples of linear data structures include arrays, linked lists, stacks, and queues.
Linear data structures are suitable for situations where data elements have a linear relationship and need to be accessed or processed in a sequential manner.
**Non-linear Data Structures:** Non-linear data structures organize data elements in a hierarchical or interconnected manner, where elements are not necessarily arranged sequentially.
Elements may have multiple relationships and connections with other elements.
Examples of non-linear data structures include trees, graphs, and hash tables.
Non-linear data structures are suitable for representing complex relationships and dependencies among data elements, allowing for efficient retrieval, traversal, and manipulation of data.

![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/c6841517-48c9-4136-9586-87ed4118e4a3)

**Static Data Structures:** Static data structures have fixed sizes and memory allocation at compile time.
Once created, the size and structure of a static data structure cannot be changed during runtime.
<br>Examples include arrays and fixed-size arrays in languages like C and C++.
Static data structures are efficient in terms of memory usage and access time but lack flexibility in handling varying amounts of data.
**Dynamic Data Structures:** Dynamic data structures allocate memory dynamically during runtime, allowing for flexibility in size and structure.
Dynamic data structures can grow or shrink as needed, adapting to changing data requirements.
<br>Examples include linked lists, stacks, queues, trees, and hash tables.
Dynamic data structures are versatile and can efficiently handle dynamic data sets, but they may incur overhead due to memory allocation and deallocation operations.

### Fundamental DS
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/a8e83c4e-1a5f-4991-a4cc-8a8a6b6d2c9c)

**Linear Data Structures:**

1. Arrays:
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/8ec2966f-aedc-4ab9-a46e-190b14477008)

Arrays are linear data structures where elements are stored sequentially in contiguous memory locations.
Elements are accessed using an index, and they have a fixed size.
Examples: One-dimensional arrays, multi-dimensional arrays.

3. Linked Lists:
Linked lists are linear data structures consisting of nodes where each node contains a value and a reference to the next node.
Nodes are connected sequentially, and elements are accessed by traversing from the head to the tail.
Examples: Singly linked lists, doubly linked lists, circular linked lists.

![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/c3017036-905d-4c77-8b06-a06b8a4d928b)


4. Stacks:
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/d6988c35-8d20-4262-8ae8-a1ce8ae564fb)

Stacks are linear data structures that follow the Last-In-First-Out (LIFO) principle.
Elements are added and removed from the same end, typically called the top.
Examples: Function call stack, expression evaluation stack.

> Attributes:
 - Capacity: The maximum number of elements that a stack can hold. This attribute is often associated with statically allocated stacks.
 - Size: The current number of elements present in the stack.
 - Top: A reference to the top element of the stack. This is where elements are added (pushed) and removed (popped).

> Operations:
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/ca957181-6795-479a-a637-92cf0f3927c9)
- Push: Add an element to the top of the stack.
If the stack is full (in the case of a bounded stack), a stack overflow error may occur.
 - Pop: Remove and return the element at the top of the stack.
If the stack is empty, a stack underflow error may occur.
 - Peek (or Top): Return the element at the top of the stack without removing it.
This operation allows you to inspect the top element without modifying the stack.
- IsEmpty: Check if the stack is empty.
Returns true if the stack contains no elements, false otherwise.
 - IsFull: Check if the stack is full (applicable only for bounded stacks).
Returns true if the stack has reached its maximum capacity, false otherwise.
- Size: Return the number of elements currently present in the stack.

5. Queues:
![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/c1a89fb5-0c1d-4282-be51-6947532a73bd)

Queues are linear data structures that follow the First-In-First-Out (FIFO) principle.
Elements are added at the rear (enqueue) and removed from the front (dequeue).
Examples: Waiting queues, task scheduling queues.

> Attributes:
- Capacity: The maximum number of elements that a queue can hold. This attribute is often associated with bounded queues.
- Size: The current number of elements present in the queue.
- Front: A reference to the front element of the queue. This is where elements are removed (dequeued).
- Rear (or Back): A reference to the rear element of the queue. This is where elements are added (enqueued).

> Operations:
- Enqueue: Add an element to the rear of the queue.
If the queue is full (in the case of a bounded queue), a queue overflow error may occur.
- Dequeue: Remove and return the element at the front of the queue.
If the queue is empty, a queue underflow error may occur.
- Front: Return the element at the front of the queue without removing it.
This operation allows you to inspect the front element without modifying the queue.
- IsEmpty: Check if the queue is empty.
Returns true if the queue contains no elements, false otherwise.
- IsFull: Check if the queue is full (applicable only for bounded queues).
Returns true if the queue has reached its maximum capacity, false otherwise.
- Size: Return the number of elements currently present in the queue.

These attributes and operations define the behavior and functionality of a queue data structure, which follows the First-In-First-Out (FIFO) principle. Queues are commonly used in various applications such as task scheduling, process management, and breadth-first search algorithms.

7. Tables:
Tables are linear data structures similar to arrays but with more flexible sizes and operations for data manipulation.
They are often implemented using arrays or dynamic arrays, providing functionality for adding, removing, and accessing elements efficiently.
Examples: Hash tables, dictionaries, associative arrays.

**Non-Linear Data Structures:**

1. Trees:
Trees are non-linear data structures consisting of nodes connected hierarchically.
Each node can have zero or more child nodes, forming a tree-like structure.
Examples: Binary trees, AVL trees, B-trees, Trie.
Insertion:
Description: Insertion involves adding a new node to the tree. The new node is typically placed in a specific position according to the tree's ordering properties (e.g., for binary search trees, nodes with values less than the parent node are placed to the left, and nodes with values greater than the parent node are placed to the right).
Algorithm:
Start at the root of the tree.
Traverse the tree from the root downwards, comparing the value of the new node with each node visited.
If the value of the new node is less than the current node, move to the left subtree; if greater, move to the right subtree.
Repeat this process until reaching a leaf node (a node with no children), then insert the new node as a child of this leaf node.
Deletion:
Description: Deletion involves removing a specific node from the tree while maintaining the tree's structural integrity and ordering properties.
Algorithm:
Find the node to be deleted.
If the node has no children, simply remove it from the tree.
If the node has one child, replace the node with its child.
If the node has two children, find the node's in-order successor (or predecessor), replace the node's value with the successor's value, and then delete the successor node from its original position.
Traversal:
Description: Traversal involves visiting each node in the tree in a specific order to perform operations such as printing, searching, or processing data.
Inorder Traversal: Traverse the left subtree, visit the root node, and then traverse the right subtree.
Preorder Traversal: Visit the root node, traverse the left subtree, and then traverse the right subtree.
Postorder Traversal: Traverse the left subtree, traverse the right subtree, and then visit the root node.
Level-order Traversal: Visit nodes level by level, starting from the root and moving to the next level.
Search:
Description: Searching involves finding a specific node or determining if a node with a given value exists in the tree.
Algorithm:
Start at the root of the tree.
Traverse the tree from the root downwards, comparing the value of the target node with each node visited.
If the value matches the target value, return the node.
If the value is less than the current node, move to the left subtree; if greater, move to the right subtree.
Repeat this process until reaching a leaf node (a node with no children), then return null (if the target node is not found).
Balancing (for balanced trees):
Description: Balancing involves adjusting the structure of the tree to ensure that it remains balanced after insertions and deletions, maintaining efficient search, insertion, and deletion operations.
Algorithms:
AVL trees: Ensure that the height difference between the left and right subtrees (balance factor) of every node is within a specified range (-1, 0, or 1).
Red-Black trees: Enforce additional constraints on the tree's structure, such as maintaining the black height of each path from the root to the leaves.
B-trees: Maintain a balanced tree structure by grouping nodes into blocks or pages and allowing multiple keys per node.
Modification:
Description: Modification involves updating the value of a node in the tree if necessary while maintaining the tree's structural integrity and ordering properties.
Enumeration:
Description: Enumeration involves iterating through all nodes in the tree using a specific traversal algorithm to access each node.
These operations form the foundation for working with tree data structures, allowing efficient manipulation and retrieval of data in various applications, including database indexing, hierarchical data representation, and efficient searching and sorting algorithms.

3. Graphs:
Graphs are non-linear data structures consisting of nodes (vertices) connected by edges.
Nodes can have multiple connections, and edges can be directed or undirected.
Examples: Directed graph, undirected graph, weighted graph.

4. Sets:
Sets are non-linear data structures that store unique elements without any particular order.
They ensure that no duplicate elements are stored, making them suitable for various mathematical and computational operations.
Examples: Hash sets, tree sets, bit sets.


Here's a table summarizing the differences between different data structures:

| Attribute           | Arrays            | Linked Lists     | Stacks           | Queues           | Trees            | Graphs           | Hash Tables      | Sets             |
|---------------------|-------------------|------------------|------------------|------------------|------------------|------------------|------------------|------------------|
| Storage             | Contiguous memory | Non-contiguous   | NA               | NA               | NA               | NA               | NA               | NA               |
|                     | block             | nodes            |                  |                  |                  |                  |                  |                  |
| Size                | Fixed             | Dynamic          | Dynamic          | Dynamic          | Dynamic          | Dynamic          | Dynamic          | Dynamic          |
| Access Time         | Constant          | Linear           | Constant         | Constant         | Logarithmic      | Logarithmic      | Average constant | Average constant |
| Insertion Time      | NA                | Constant         | Constant         | Constant         | Logarithmic      | Logarithmic      | Average constant | Average constant |
| Deletion Time       | NA                | Constant         | Constant         | Constant         | Logarithmic      | Logarithmic      | Average constant | Average constant |
| Usage               | Random access     | Sequential       | LIFO             | FIFO             | Hierarchical     | Networks        | Key-value store  | Unique elements  |
| Operations          | Index-based       | Pointer-based    | Push, Pop        | Enqueue, Dequeue | Insert, Delete   | Insert, Delete   | Insert, Delete   | Membership check |
| Examples            | Static lists      | Memory           | Undo mechanisms  | Print queues     | File systems     | Social networks  | Databases        | Mathematical sets|

This table provides a quick overview of the differences between various fundamental data structures based on key attributes such as storage, size, access time, operations, and examples of usage.
Each of these data structures serves different purposes and has specific characteristics, operations, and use cases in solving computational problems and organizing data efficiently.


## Algorithmn Design

![image](https://github.com/nandini-gangrade/Hexaware-Python-Training/assets/87817417/d7b5f951-903f-4ab2-be40-cfdac886163c)

> Searching Algorithms:

- Linear Search:
Linear search iterates through each element in a list sequentially until the target element is found or the end of the list is reached.
Example: Searching for a specific number in an unsorted list of numbers.

- Binary Search:
Binary search is a divide-and-conquer algorithm that requires the list to be sorted.
It repeatedly divides the search interval in half until the target element is found or the search interval is empty.
Example: Searching for a specific number in a sorted list of numbers.

> Sorting Algorithms:

- Bubble Sort:
Bubble sort compares adjacent elements and swaps them if they are in the wrong order.
It repeatedly passes through the list until the list is sorted.
Example: Sorting an array of numbers in ascending order.

``` Given list [77, 42, 35, 12, 100, 5] in increasing order:
Pass 1:
Compare adjacent elements and swap if necessary:
[42, 77, 35, 12, 100, 5]
[42, 35, 77, 12, 100, 5]
[42, 35, 12, 77, 100, 5]
[42, 35, 12, 77, 100, 5]
[42, 35, 12, 77, 5, 100]
Pass 2:
Compare adjacent elements and swap if necessary:
[35, 42, 12, 77, 5, 100]
[35, 12, 42, 77, 5, 100]
[35, 12, 42, 5, 77, 100]
[35, 12, 42, 5, 77, 100]
Pass 3:
Compare adjacent elements and swap if necessary:
[12, 35, 42, 5, 77, 100]
[12, 35, 5, 42, 77, 100]
[12, 35, 5, 42, 77, 100]
Pass 4:
Compare adjacent elements and swap if necessary:
[12, 5, 35, 42, 77, 100]
[12, 5, 35, 42, 77, 100]
Pass 5:
Compare adjacent elements and swap if necessary:
[5, 12, 35, 42, 77, 100]
Now, the list is sorted in increasing order: [5, 12, 35, 42, 77, 100].
```

- Selection Sort:
Selection sort divides the input list into two parts: sorted and unsorted.
It repeatedly selects the smallest (or largest) element from the unsorted part and moves it to the sorted part.
Example: Sorting an array of numbers in ascending order.
```
given list [75, 28, 65, 30, 20].
Selection Sort works by repeatedly finding the minimum element from the unsorted part of the list and swapping it with the first unsorted element. Here's how it works step by step:
Pass 1:
Find the minimum element in the entire list and swap it with the first element.
The minimum element is 20, so swap it with 75.
The list becomes [20, 28, 65, 30, 75].
Pass 2:
Find the minimum element in the sublist starting from the second element and swap it with the second element.
The minimum element is 28, so leave it as it is.
The list remains [20, 28, 65, 30, 75].
Pass 3:
Find the minimum element in the sublist starting from the third element and swap it with the third element.
The minimum element is 30, so swap it with 65.
The list becomes [20, 28, 30, 65, 75].
Pass 4:
Find the minimum element in the sublist starting from the fourth element and swap it with the fourth element.
The minimum element is 65, so leave it as it is.
The list remains [20, 28, 30, 65, 75].
Pass 5:
There is only one element left, so no action is needed.
Now, the list [75, 28, 65, 30, 20] is sorted using the Selection Sort algorithm. The sorted list is [20, 28, 30, 65, 75].
```
- Insertion Sort:
Insertion sort builds the final sorted list one element at a time by repeatedly taking the next element and inserting it into the proper position in the already sorted part.
Example: Sorting an array of numbers in ascending order.
```
given list [12, 10, 36, 6, 24].
Pass 1:
Start with the second element (10).
Compare it with the element to its left (12).
Since 10 is smaller than 12, swap them.
The list becomes [10, 12, 36, 6, 24].
Pass 2:
Start with the third element (36).
Compare it with the elements to its left (12 and 10).
Since 36 is larger than both 12 and 10, leave it as it is.
The list remains [10, 12, 36, 6, 24].
Pass 3:
Start with the fourth element (6).
Compare it with the elements to its left (36, 12, and 10).
Since 6 is smaller than 36, shift 36 to the right.
Continue comparing with 12 and 10 and shift them to the right accordingly.
Insert 6 into its correct position.
The list becomes [6, 10, 12, 36, 24].
Pass 4:
Start with the fifth element (24).
Compare it with the elements to its left (36 and 12).
Since 24 is smaller than 36, shift 36 to the right.
Insert 24 into its correct position.
The list becomes [6, 10, 12, 24, 36].
Now, the list [12, 10, 36, 6, 24] is sorted using the Insertion Sort algorithm. The sorted list is [6, 10, 12, 24, 36].
```
- Merge Sort:
Merge sort is a divide-and-conquer algorithm that divides the input list into smaller sublists, sorts them, and then merges them back together.
It is a stable sorting algorithm and guarantees O(n log n) time complexity.
Example: Sorting an array of numbers in ascending order.
```
Divide:
Split the list [75, 28, 65, 30, 20] into two halves: [75, 28] and [65, 30, 20].
Recursively sort:
Apply Merge Sort to each half:
For [75, 28]: Split into [75] and [28], no further split needed.
For [65, 30, 20]: Split into [65] and [30, 20], then split [30, 20] into [30] and [20].
Now, merge the sorted sublists: [20, 30].
Merge:
Merge the sorted sublists [75] and [28] back together: [28, 75].
Merge the sorted sublists [65] and [20, 30] back together: [20, 30, 65].
Now, merge the two sorted halves [28, 75] and [20, 30, 65]: [20, 28, 30, 65, 75].
```
- Quick Sort:
Quick sort is a divide-and-conquer algorithm that selects a pivot element and partitions the input list into two sublists: elements smaller than the pivot and elements larger than the pivot.
It then recursively sorts the two sublists.
Example: Sorting an array of numbers in ascending order.
```
Quick Sort algorithm on the list [2, 1, 3, 5, 4] with the pivot element set to 3.
Partitioning Step:
Start with the list [2, 1, 3, 5, 4].
Choose the pivot element 3.
Partition the list around the pivot:
Elements less than 3 (1, 2) on the left side.
Pivot element 3 in the middle.
Elements greater than 3 (4, 5) on the right side.
The partitioned list becomes [2, 1, 3, 5, 4] (left sublist) | 3 (pivot) | [5, 4] (right sublist).
Recursive Sorting:
Apply Quick Sort recursively to the left and right sublists.
Left sublist [2, 1]:
Choose the pivot element 2.
Partition the sublist around the pivot:
Elements less than 2 (1) on the left side.
Pivot element 2 in the middle.
Elements greater than 2 (empty) on the right side.
The partitioned sublist becomes [1] (left sublist) | 2 (pivot) | [] (right sublist).
Since both left and right sublists are sorted, no further action is needed.Right sublist [5, 4]:
Choose the pivot element 5.
Partition the sublist around the pivot:
Elements less than 5 (4) on the left side.
Pivot element 5 in the middle.
Elements greater than 5 (empty) on the right side.
The partitioned sublist becomes [4] (left sublist) | 5 (pivot) | [] (right sublist).
Since both left and right sublists are sorted, no further action is needed.
Result:
Combine the sorted sublists [1, 2, 3, 4, 5].
So, the sorted list using Quick Sort with the pivot element set to 3 is [1, 2, 3, 4, 5].
```
These algorithms provide different approaches to searching and sorting data, each with its own advantages and disadvantages in terms of time complexity, space complexity, stability, and ease of implementation.
