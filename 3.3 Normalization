# Normalization in Databases

## What is Normalization?
Normalization is a process used in database design to organize data efficiently, reduce redundancy, and ensure data integrity. It involves breaking down a large table into smaller, more manageable tables and establishing relationships between them. Normalization helps in eliminating data anomalies and ensures that the database structure adheres to certain rules.

## Why Normalization?
Normalization is essential for several reasons:
- Reduces data redundancy
- Minimizes update anomalies
- Improves data integrity
- Enhances database performance
- Facilitates easier database maintenance and management

### Keywords:

- **Primary Key**: A unique identifier for each record in a table.
  - Example: Student_ID in a table of students.
  
- **Composite Primary Key**: A primary key that consists of more than one attribute.
  - Example: {Order_ID, Product_ID} in a table of orders and products.

- **Foreign Key**: A column in one table that references the primary key in another table.
  - Example: Department_ID in a table of employees, referencing the Department_ID in a table of departments.

- **Functional Dependency**: When knowing the value of one attribute determines the value of another attribute.
  - Example: Knowing the Social Security Number (SSN) of a person determines their Name.

- **Transitive Dependency**: When one non-key attribute determines another non-key attribute indirectly through a third attribute.
  - Example: In a table where City determines State, and State determines Country, City → State → Country is a transitive dependency.

- **Indirect Dependency**: Similar to transitive dependency, it refers to a situation where one attribute depends on another, which, in turn, depends on a third attribute.
  - Example: If a customer's Address depends on the Location, and the Location depends on the ZIP code, then Address → Location → ZIP code is an indirect dependency.

- **Candidate Key**: A minimal set of attributes that uniquely identify each tuple in a relation.
  - Example: {Student_ID} or {Email} can be candidate keys in a table of students.

- **Atomic Value**: A value that cannot be divided further.
  - Example: A cell in a table containing a single value like "John Smith" or "123 Main Street".

- **Partial Dependency**: When non-key attributes are dependent on only part of the primary key.
  - Example: In a table where {Student_ID, Course} → Grade, if Grade depends only on Course, it's a partial dependency.

- **Normalization**: The process of organizing data in a database to reduce redundancy and improve data integrity. (safety)
  - Example: Splitting a single table with customer information into separate tables for customers and their orders to avoid duplicating customer data.

- **Denormalization**: The process of intentionally adding redundancy to a database for performance reasons.
  - Example: Storing calculated values, like total order amount, in a table to avoid having to calculate them each time they're needed.

- **Anomaly**: An error or inconsistency in the data that occurs due to improper database design.
  - Example: Insertion, update, or deletion anomalies that arise when a database table is not properly normalized.

- **Dependency**: A relationship between attributes in a database, where the value of one attribute determines the value of another.
  - Example: The value of a Customer_ID attribute determines the corresponding customer's Name and Address.

## Normalization Forms
### 1. First Normal Form (1NF)
- **What**: Ensures that each column in the table contains atomic (indivisible) values.
- **Why**: Avoids repeating groups and ensures data integrity.
- **How**: Splitting multi-valued attributes into separate columns or rows.

      - Don't use row order to convey info.
      - Keep data types consistent.
      - Every row needs a unique identifier (Primary Key).
      - Don't repeat groups of data.

**Example**:

**Incorrect Table (1NF)**:

| Band_Name   | Members              |
|-------------|----------------------|
| Beatles     | Paul, John, George, Ringo |

**Incorrect Table Explanation**: In the incorrect table, the "Members" column violates 1NF by storing multiple member names in a single cell.

**Correct Table (1NF)**:

| Band_Name   | Member       |
|-------------|--------------|
| Beatles     | Paul         |
| Beatles     | John         |
| Beatles     | George       |
| Beatles     | Ringo        |

**Correct Table Explanation (1NF)**: The corrected table splits the multi-valued attribute "Members" into separate rows, ensuring atomic values in each cell.

### 2. Second Normal Form (2NF)
- **What**: Ensures that all non-key attributes are fully functionally dependent on the primary key.
- **Why**: Eliminates partial dependencies and improves data integrity.
- **How**: Splitting tables to remove partial dependencies.

      - Follow 1NF.
      - Have a special key made from more than one part (Composite Primary Key).
      - Everything else should depend fully on that key.

**Example**:

**Incorrect Table (2NF)**:

| Band_Name   | Member       | Role           |
|-------------|--------------|----------------|
| Beatles     | Paul         | Lead Singer    |
| Beatles     | John         | Guitarist      |
| Beatles     | George       | Guitarist      |
| Beatles     | Ringo        | Drummer        |

**Incorrect Table Explanation**: In the incorrect table, the "Role" attribute depends on the "Band_Name," which is part of the composite primary key, creating partial dependencies.

**Correct Tables (2NF)**:

| Band_Name   | Member       |
|-------------|--------------|
| Beatles     | Paul         |
| Beatles     | John         |
| Beatles     | George       |
| Beatles     | Ringo        |

| Member       | Role           |
|--------------|----------------|
| Paul         | Lead Singer    |
| John         | Guitarist      |
| George       | Guitarist      |
| Ringo        | Drummer        |

**Correct Tables Explanation (2NF)**: We split the original table into two separate tables to remove partial dependencies. Each table now has a single primary key, and all non-key attributes are fully functionally dependent on it.

### 3. Third Normal Form (3NF)
- **What**: Ensures that there are no transitive dependencies between non-key attributes.
- **Why**: Removes transitive dependencies and improves data integrity.
- **How**: Further splitting tables to eliminate transitive dependencies.

      - Meet 2NF.
      - No indirect dependencies between non-key items.

**Example**:

**Incorrect Table (3NF)**:

| Member       | Role           | Band_Name   |
|--------------|----------------|-------------|
| Paul         | Lead Singer    | Beatles     |
| John         | Guitarist      | Beatles     |
| George       | Guitarist      | Beatles     |
| Ringo        | Drummer        | Beatles     |

**Incorrect Table Explanation**: In the incorrect table, "Band_Name" depends on "Member," which is not a primary key, creating a transitive dependency.

**Correct Tables (3NF)**:

| Member_ID | Member       | Band_ID |
|-----------|--------------|---------|
| 1         | Paul         | 1       |
| 2         | John         | 1       |
| 3         | George       | 1       |
| 4         | Ringo        | 1       |

| Band_ID | Band_Name   |
|---------|-------------|
| 1       | Beatles     |

| Role_ID | Role         |
|---------|--------------|
| 1       | Lead Singer  |
| 2       | Guitarist    |
| 3       | Drummer      |

**Correct Tables Explanation (3NF)**: We further normalize the data by splitting attributes into multiple tables to remove transitive dependencies. Each table represents a distinct entity, and there are no transitive dependencies between non-key attributes.

### 4. Boyce-Codd Normal Form (BCNF)
- **What**: Ensures that every determinant is a candidate key.
- **Why**: Eliminates non-trivial functional dependencies.
- **How**: Decomposing tables until each satisfies the criteria for BCNF.

      - Satisfy 3NF.
      - Every reason (determinant) for something must be a potential Primary Key (Candidate Key).

**Example**:

**Incorrect Table (BCNF)**:

| Member       | Role           |
|--------------|----------------|
| Paul         | Lead Singer    |
| John         | Guitarist      |
| George       | Guitarist      |
| Ringo        | Drummer        |

**Incorrect Table Explanation**: In the incorrect table, both "Member" and "Role" are candidate keys, but they determine each other, creating non-trivial functional dependencies.

**Correct Tables (BCNF)**:

| Member_ID | Member       | Role_ID |
|-----------|--------------|---------|
| 1         | Paul         | 1       |
| 2         | John         | 2       |
| 3         | George       | 2       |
| 4         | Ringo        | 3       |

| Role_ID | Role         |
|---------|--------------|
| 1       | Lead Singer  |
| 2       | Guitarist    |
| 3       | Drummer      |

**Correct Tables Explanation (BCNF)**: We introduce surrogate keys ("Member_ID" and "Role_ID") to ensure each table has a single candidate key. Now, each determinant uniquely identifies the attributes, adhering to BCNF.

This explanation provides an overview of each normalization form, including examples of incorrect and correct tables for each, along with explanations of what was wrong and how it was corrected.
